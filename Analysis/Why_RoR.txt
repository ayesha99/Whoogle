	After much consideration, we decided that Ruby on Rails would be our architecture of choice. To come up with this conclusion, we examined the interrelationship between our skillsets, our perception of the project, and the architectures available to us.

	We first analyzed the skillsets of our group members. We found that two of our four group members were familiar with Ruby on Rails, and that none of the four members were familiar with any other web development framework. We believe that this familiarity gives Ruby on Rails a slight edge over the other frameworks we considered.
	However, the main reason we chose Ruby on Rails is that our use cases seem to align with the way Rails processes data as a backend. In particular, we determined that the use cases involving creating a relationship map of users should be faster with Rails than any other framework we analyzed, which is the main nonfunctional requirement for this use case. Rails is great for highly CPU-driven applications, and we are confident that creating a relationship map of users would be very CPU intensive. Additionally, Rails works very well using relational databases through Active Record. We believe we need to use a relational database if we presume to store the connections between people within our database. If we decide that we should just store something that a relational database would not be suited for, we always have the option of changing the database if we use Rails. (https://www.quora.com/How-does-Ruby-on-Rails-compare-with-the-MEAN-stack)
	Additionally, we analyzed some major Ruby on Rails "doctrines" (http://rubyonrails.org/doctrine/) and found that these principles will guide both our understanding and reasoning behind the organization and structure of Ruby on Rails in particular and web development in general.

	Regarding alternatives, we were and still are very willing to change our architecture if we find some obvious reason to do so. The earlier on in the process that we find these issues, the easier they are to change.
	In particular, we examined the MEAN stack vs RoR and determined that MEAN was insufficient as our project stands. We basically ignored the benefits and drawbacks of Mongo and Angular because Mongo and Angular can both work with RoR. Additionally, we weren't too concerned with which language we used or how consistantly the language is used, as long as the backend matched with our use cases. 
	Thus, when determining which framework to use, we determined whether we could see any obvious bottlenecks for any use cases. We found that, which Node.js is good for highly concurrent, low-cpu processing, since we are not serving a lot of chat requests or providing realtime metrics, we cannot exactly leverage this benefit. However, the benefit of event-driving non-blocking I/O is lost when we use the CPU a lot, which is exactly what we are doing when we make the relationship map. While we understand that there are workarounds to this, we assume that RoR will handle the inherent performance bottlenecks within our Use Cases in general, with a particular emphasis on the relationship mapping.

Thus, we came to our conclusion through identifying the bottlenecks in our use cases, and then identifying features of frameworks that may handle these bottlenecks. Additionally we analyzed our team's personal skillset, and then chose the web framework that we think can guide us best throughout the process.
